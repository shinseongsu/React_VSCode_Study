"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _diagnostic = _interopRequireWildcard(require("@parcel/diagnostic"));

var _utils = require("@parcel/utils");

var _Environment = require("./Environment");

var _path = _interopRequireDefault(require("path"));

var _browserslist = _interopRequireDefault(require("browserslist"));

var _TargetDescriptor = _interopRequireWildcard(require("./TargetDescriptor.schema"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DEFAULT_DEVELOPMENT_ENGINES = {
  node: 'current',
  browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']
};
const DEFAULT_PRODUCTION_ENGINES = {
  browsers: ['>= 0.25%'],
  node: '8'
};
const DEFAULT_DIST_DIRNAME = 'dist';
const COMMON_TARGETS = ['main', 'module', 'browser', 'types'];

class TargetResolver {
  constructor(options) {
    _defineProperty(this, "fs", void 0);

    _defineProperty(this, "options", void 0);

    this.fs = options.inputFS;
    this.options = options;
  }

  async resolve(rootDir) {
    let optionTargets = this.options.targets;
    let targets;
    let files = [];

    if (optionTargets) {
      if (Array.isArray(optionTargets)) {
        if (optionTargets.length === 0) {
          throw new _diagnostic.default({
            diagnostic: {
              message: `Targets is an empty array`,
              origin: '@parcel/core'
            }
          });
        } // If an array of strings is passed, it's a filter on the resolved package
        // targets. Load them, and find the matching targets.


        let packageTargets = await this.resolvePackageTargets(rootDir);
        targets = optionTargets.map(target => {
          let matchingTarget = packageTargets.targets.get(target);

          if (!matchingTarget) {
            throw new _diagnostic.default({
              diagnostic: {
                message: `Could not find target with name "${target}"`,
                origin: '@parcel/core'
              }
            });
          }

          return matchingTarget;
        });
        files = packageTargets.files;
      } else {
        // Otherwise, it's an object map of target descriptors (similar to those
        // in package.json). Adapt them to native targets.
        targets = Object.entries(optionTargets).map(([name, _descriptor]) => {
          let _parseDescriptor = parseDescriptor(name, _descriptor, null, {
            targets: optionTargets
          }),
              {
            distDir
          } = _parseDescriptor,
              descriptor = _objectWithoutProperties(_parseDescriptor, ["distDir"]);

          if (!distDir) {
            let optionTargetsString = JSON.stringify(optionTargets, null, '\t');
            throw new _diagnostic.default({
              diagnostic: {
                message: `Missing distDir for target "${name}"`,
                origin: '@parcel/core',
                codeFrame: {
                  code: optionTargetsString,
                  codeHighlights: (0, _diagnostic.generateJSONCodeHighlights)(optionTargetsString, [{
                    key: `/${name}`,
                    type: 'value'
                  }])
                }
              }
            });
          }

          return {
            name,
            distDir: _path.default.resolve(this.fs.cwd(), distDir),
            publicUrl: descriptor.publicUrl,
            env: (0, _Environment.createEnvironment)({
              engines: descriptor.engines,
              context: descriptor.context,
              isLibrary: descriptor.isLibrary,
              includeNodeModules: descriptor.includeNodeModules,
              outputFormat: descriptor.outputFormat
            }),
            sourceMap: descriptor.sourceMap
          };
        });
      }

      if (this.options.serve) {
        // In serve mode, we only support a single browser target. If the user
        // provided more than one, or the matching target is not a browser, throw.
        if (targets.length > 1) {
          throw new _diagnostic.default({
            diagnostic: {
              message: `More than one target is not supported in serve mode`,
              origin: '@parcel/core'
            }
          });
        }

        if (targets[0].env.context !== 'browser') {
          throw new _diagnostic.default({
            diagnostic: {
              message: `Only browser targets are supported in serve mode`,
              origin: '@parcel/core'
            }
          });
        }
      }
    } else {
      // Explicit targets were not provided. Either use a modern target for server
      // mode, or simply use the package.json targets.
      if (this.options.serve) {
        var _serveOptions$publicU;

        // In serve mode, we only support a single browser target. Since the user
        // hasn't specified a target, use one targeting modern browsers for development
        let serveOptions = this.options.serve;
        targets = [{
          name: 'default',
          // For serve, write the `dist` to inside the parcel cache, which is
          // temporary, likely in a .gitignore or similar, but still readily
          // available for introspection by the user if necessary.
          distDir: _path.default.resolve(this.options.cacheDir, DEFAULT_DIST_DIRNAME),
          publicUrl: (_serveOptions$publicU = serveOptions.publicUrl) !== null && _serveOptions$publicU !== void 0 ? _serveOptions$publicU : '/',
          env: (0, _Environment.createEnvironment)({
            context: 'browser',
            engines: {
              browsers: DEFAULT_DEVELOPMENT_ENGINES.browsers
            }
          })
        }];
      } else {
        let packageTargets = await this.resolvePackageTargets(rootDir);
        targets = Array.from(packageTargets.targets.values());
        files = packageTargets.files;
      }
    }

    return {
      targets,
      files
    };
  }

  async resolvePackageTargets(rootDir) {
    var _this$options$default;

    let conf = await (0, _utils.loadConfig)(this.fs, _path.default.join(rootDir, 'index'), ['package.json']);
    let pkg;
    let pkgContents;
    let pkgFilePath;
    let pkgDir;

    if (conf) {
      pkg = conf.config;
      let pkgFile = conf.files[0];

      if (pkgFile == null) {
        throw new _diagnostic.default({
          diagnostic: {
            message: `Expected package.json file in ${rootDir}`,
            origin: '@parcel/core'
          }
        });
      }

      pkgFilePath = pkgFile.filePath;
      pkgDir = _path.default.dirname(pkgFilePath);
      pkgContents = await this.fs.readFile(pkgFilePath, 'utf8');
    } else {
      pkg = {};
      pkgDir = this.fs.cwd();
    }

    let pkgTargets = pkg.targets || {};
    let pkgEngines = parseEngines(pkg.engines, pkgFilePath, pkgContents, '/engines', 'Invalid engines in package.json') || {};

    if (!pkgEngines.browsers) {
      let browserslistBrowsers = _browserslist.default.loadConfig({
        path: rootDir
      });

      if (browserslistBrowsers) {
        pkgEngines.browsers = browserslistBrowsers;
      }
    }

    let targets = new Map();
    let node = pkgEngines.node;
    let browsers = pkgEngines.browsers; // If there is a separate `browser` target, or an `engines.node` field but no browser targets, then
    // the `main` and `module` targets refer to node, otherwise browser.

    let mainContext = pkg.browser || pkgTargets.browser || node && !browsers ? 'node' : 'browser';
    let moduleContext = pkg.browser || pkgTargets.browser ? 'browser' : mainContext;
    let defaultEngines = (_this$options$default = this.options.defaultEngines) !== null && _this$options$default !== void 0 ? _this$options$default : this.options.mode === 'production' ? DEFAULT_PRODUCTION_ENGINES : DEFAULT_DEVELOPMENT_ENGINES;
    let context = browsers || !node ? 'browser' : 'node';

    if (context === 'browser' && pkgEngines.browsers == null) {
      pkgEngines.browsers = defaultEngines.browsers;
    } else if (context === 'node' && pkgEngines.node == null) {
      pkgEngines.node = defaultEngines.node;
    }

    for (let targetName of COMMON_TARGETS) {
      let targetDist;

      if (targetName === 'browser' && pkg[targetName] != null && typeof pkg[targetName] === 'object') {
        // The `browser` field can be a file path or an alias map.
        targetDist = pkg[targetName][pkg.name];
      } else {
        targetDist = pkg[targetName];
      }

      if (typeof targetDist === 'string' || pkgTargets[targetName]) {
        var _descriptor$publicUrl, _descriptor$engines, _descriptor$context, _descriptor$includeNo, _descriptor$outputFor;

        let distDir;
        let distEntry;

        let _descriptor = pkgTargets[targetName] || {};

        if (typeof targetDist === 'string') {
          distDir = _path.default.resolve(pkgDir, _path.default.dirname(targetDist));
          distEntry = _path.default.basename(targetDist);
        } else {
          distDir = _path.default.resolve(pkgDir, DEFAULT_DIST_DIRNAME, targetName);
        }

        let descriptor = parseDescriptor(targetName, _descriptor, pkgFilePath, pkgContents);
        targets.set(targetName, {
          name: targetName,
          distDir,
          distEntry,
          publicUrl: (_descriptor$publicUrl = descriptor.publicUrl) !== null && _descriptor$publicUrl !== void 0 ? _descriptor$publicUrl : '/',
          env: (0, _Environment.createEnvironment)({
            engines: (_descriptor$engines = descriptor.engines) !== null && _descriptor$engines !== void 0 ? _descriptor$engines : pkgEngines,
            context: (_descriptor$context = descriptor.context) !== null && _descriptor$context !== void 0 ? _descriptor$context : targetName === 'browser' ? 'browser' : targetName === 'module' ? moduleContext : mainContext,
            includeNodeModules: (_descriptor$includeNo = descriptor.includeNodeModules) !== null && _descriptor$includeNo !== void 0 ? _descriptor$includeNo : false,
            outputFormat: (_descriptor$outputFor = descriptor.outputFormat) !== null && _descriptor$outputFor !== void 0 ? _descriptor$outputFor : targetName === 'module' ? 'esmodule' : 'commonjs',
            isLibrary: true
          }),
          sourceMap: descriptor.sourceMap
        });
      }
    } // Custom targets


    for (let targetName in pkgTargets) {
      if (COMMON_TARGETS.includes(targetName)) {
        continue;
      }

      let _descriptor = pkgTargets[targetName];
      let distPath = pkg[targetName];
      let distDir;
      let distEntry;

      if (distPath == null) {
        distDir = _path.default.resolve(pkgDir, DEFAULT_DIST_DIRNAME, targetName);
      } else {
        if (typeof distPath !== 'string') {
          let contents = typeof pkgContents === 'string' ? pkgContents : // $FlowFixMe
          JSON.stringify(pkgContents, null, '\t');
          throw new _diagnostic.default({
            diagnostic: {
              message: `Invalid distPath for target "${targetName}"`,
              origin: '@parcel/core',
              language: 'json',
              filePath: pkgFilePath || undefined,
              codeFrame: {
                code: contents,
                codeHighlights: (0, _diagnostic.generateJSONCodeHighlights)(contents, [{
                  key: `/${targetName}`,
                  type: 'value',
                  message: 'Expected type string'
                }])
              }
            }
          });
        }

        distDir = _path.default.resolve(pkgDir, _path.default.dirname(distPath));
        distEntry = _path.default.basename(distPath);
      }

      if (_descriptor) {
        var _descriptor$publicUrl2, _descriptor$engines2;

        let descriptor = parseDescriptor(targetName, _descriptor, pkgFilePath, pkgContents);
        targets.set(targetName, {
          name: targetName,
          distDir,
          distEntry,
          publicUrl: (_descriptor$publicUrl2 = descriptor.publicUrl) !== null && _descriptor$publicUrl2 !== void 0 ? _descriptor$publicUrl2 : '/',
          env: (0, _Environment.createEnvironment)({
            engines: (_descriptor$engines2 = descriptor.engines) !== null && _descriptor$engines2 !== void 0 ? _descriptor$engines2 : pkgEngines,
            context: descriptor.context,
            includeNodeModules: descriptor.includeNodeModules,
            outputFormat: descriptor.outputFormat,
            isLibrary: descriptor.isLibrary
          }),
          sourceMap: descriptor.sourceMap
        });
      }
    } // If no explicit targets were defined, add a default.


    if (targets.size === 0) {
      targets.set('default', {
        name: 'default',
        distDir: _path.default.resolve(this.fs.cwd(), DEFAULT_DIST_DIRNAME),
        publicUrl: '/',
        env: (0, _Environment.createEnvironment)({
          engines: pkgEngines,
          context
        })
      });
    }

    return {
      targets,
      files: conf ? conf.files : []
    };
  }

}

exports.default = TargetResolver;

function parseEngines(engines, pkgPath, pkgContents, prependKey, message) {
  if (engines === undefined) {
    return engines;
  } else {
    _utils.validateSchema.diagnostic(_TargetDescriptor.ENGINES_SCHEMA, engines, pkgPath, pkgContents, '@parcel/core', prependKey, message); // $FlowFixMe we just verified this


    return engines;
  }
}

function parseDescriptor(targetName, descriptor, pkgPath, pkgContents) {
  _utils.validateSchema.diagnostic(_TargetDescriptor.default, descriptor, pkgPath, pkgContents, '@parcel/core', `/targets/${targetName}`, `Invalid target descriptor for target "${targetName}"`); // $FlowFixMe we just verified this


  return descriptor;
}