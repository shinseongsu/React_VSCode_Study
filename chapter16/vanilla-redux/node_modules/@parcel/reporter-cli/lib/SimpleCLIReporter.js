"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._setStdio = _setStdio;
exports._report = _report;
exports.default = void 0;

var _ink = require("ink");

var _plugin = require("@parcel/plugin");

var React = _interopRequireWildcard(require("react"));

var _BundleReport = _interopRequireDefault(require("./BundleReport"));

var _utils = require("@parcel/utils");

var _utils2 = require("./utils");

var _logLevels = _interopRequireDefault(require("./logLevels"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var _default = new _plugin.Reporter({
  report({
    event,
    options
  }) {
    _report(event, options);
  }

});

exports.default = _default;
let stdout = process.stdout;
let stderr = process.stderr;
let wroteServerInfo = false; // Exported only for test

function _setStdio(stdoutLike, stderrLike) {
  stdout = stdoutLike;
  stderr = stderrLike;
} // Exported only for test


function _report(event, options) {
  let logLevelFilter = _logLevels.default[options.logLevel || 'info'];

  switch (event.type) {
    case 'buildStart':
      {
        if (options.serve && !wroteServerInfo) {
          var _options$serve$host;

          writeOut(`Server running at ${options.serve.https ? 'https' : 'http'}://${(_options$serve$host = options.serve.host) !== null && _options$serve$host !== void 0 ? _options$serve$host : 'localhost'}:${options.serve.port}`);
          wroteServerInfo = true;
        }

        break;
      }

    case 'buildProgress':
      {
        if (logLevelFilter < _logLevels.default.info) {
          break;
        }

        let message = (0, _utils2.getProgressMessage)(event);

        if (message != null) {
          writeOut(message);
        }

        break;
      }

    case 'buildSuccess':
      if (logLevelFilter < _logLevels.default.info) {
        break;
      }

      writeOut(`Built in ${(0, _utils.prettifyTime)(event.buildTime)}`);

      if (options.mode === 'production') {
        (0, _ink.render)(React.createElement(_BundleReport.default, {
          bundleGraph: event.bundleGraph
        }));
      }

      break;

    case 'buildFailure':
      if (logLevelFilter < _logLevels.default.error) {
        break;
      }

      writeDiagnostic(event.diagnostics, true);
      break;

    case 'log':
      {
        switch (event.level) {
          case 'success':
          case 'progress':
            writeOut(event.message);
            break;

          case 'verbose':
          case 'info':
            writeDiagnostic(event.diagnostics);
            break;

          case 'warn':
          case 'error':
            writeDiagnostic(event.diagnostics, true);
            break;

          default:
            throw new Error('Unknown log level ' + event.level);
        }
      }
  }
}

function writeDiagnostic(diagnostics, isError) {
  for (let diagnostic of diagnostics) {
    let {
      message,
      stack,
      codeframe,
      hints
    } = (0, _utils.prettyDiagnostic)(diagnostic);

    if (message) {
      writeOut(message, isError);
    }

    if (stack) {
      writeOut(stack, isError);
    }

    if (codeframe) {
      writeOut(codeframe, isError);
    }

    for (let hint of hints) {
      writeOut(hint, isError);
    }
  }
}

function writeOut(message, isError) {
  if (isError) {
    stderr.write(message + '\n');
  } else {
    stdout.write(message + '\n');
  }
}